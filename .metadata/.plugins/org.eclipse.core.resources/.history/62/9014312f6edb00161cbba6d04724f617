import java.awt.Color;
import java.awt.Polygon;
import java.util.ArrayList;

//Thomas Varano
//Larger blocks that are actually used
//Dec 26, 2016

/**
 * @author varanoth 
 * be sure to set small block 0 as the block you want to rotate
 *         around
 */

public class TetrisShapes
{
   private int c, r, dx, blockAmount, blockSize, resetTime;
   public int position, ground;
   public Location location;
   private long pacer;
   private boolean left, right, speedUp, rotate, collision, clear, still, 
                     rotatable, moveableRight, moveableLeft, moveableDown;
   private ArrayList<TetrisBlock> blocks;
   private String label;
   private Color color;
   private Location[][] grid;

   public TetrisShapes(int r, int c, int blockAmount) {
      this.r = r;
      this.c = c;
      setBlocks(new ArrayList<TetrisBlock>());
      left = right = speedUp = false;
      setLabel("");
      this.blockAmount = blockAmount;
      position = 0;
      dx = blockSize;
      ground = 0;
      rotatable = true;
      resetTime = 1;
      moveableDown = moveableLeft = moveableRight = true;
      location = null;
   }

   public void init() {
      for (int i = 0; i < blockAmount; i++) {
         blocks.add(new TetrisBlock(r, c, blockSize + 1));
      }
      for (int i = 0; i < blocks.size(); i++) {
         blocks.get(i).setGrid(grid);
         blocks.get(i).setDx(dx);
         blocks.get(i).setColor(color);
         blocks.get(i).setBlockSize(blockSize);
         blocks.get(i).setGround(ground);
         blocks.get(i).setResetTime(resetTime);
      }
   }

   public void still(Location l) {
      still = true;
      for (int i = 0; i < blocks.size(); i++) {
         blocks.get(i).setLocation(l);
      }
   }
   
   public void update(){
      int resetter = resetTime;
      if (speedUp) {
         resetter = resetTime / 3;
      } else {
         resetter = resetTime;
      }
      pacer++;
      if (pacer % resetter == 0) {
         for (int i = 0; i < blocks.size(); i++) {
            if (!still) {
               blocks.get(i).update();
               // TODO if any of the blocks are not moveable, i dont want it to
               // move
               // ALSO WAIT NO ONLY MOVE DOWN UNTIL GIVEN THE OK TO DO SO.
               // doesnt move down until the ENTIRE row is cleared, doesnt
               // matter if it has the opportunity to
               if (!blocks.get(i).canMoveDown())
                  moveableDown = false;
               if (!blocks.get(i).canMoveLeft())
                  moveableLeft = false;
               if (!blocks.get(i).canMoveRight())
                  moveableRight = false;

               if (moveableDown) {
                  blocks.get(i).setR(blocks.get(i).getR() + 1);
                  System.out.println(blocks.get(i));
               }
               if (right) {
                  if (moveableRight) {
                     System.out.println("right");
                     blocks.get(i).setC(blocks.get(i).getC() + 1);
                     right = false;
                  }
               } else if (left) {
                  if (moveableLeft) {
                     System.out.println("left");
                     blocks.get(i).setC(blocks.get(i).getC() - 1);
                     left = false;
                  }
               }
               if (rotate) {
                  position++;
                  setRotate(false);
               }
               if (position == 4) {
                  position = 0;
               }
            }
            if (position == 0){
               blocks.get(i).setC(c+blocks.get(i).getCFromCenter());
               blocks.get(i).setR(r+blocks.get(i).getRFromCenter());
            }
            if (position == 1){
               blocks.get(i).setC(c+blocks.get(i).getRFromCenter());
               blocks.get(i).setR(r-blocks.get(i).getCFromCenter());
            }
            if (position == 2){
               blocks.get(i).setC(c-blocks.get(i).getCFromCenter());
               blocks.get(i).setR(r-blocks.get(i).getRFromCenter());
            }
            if (position == 3){
               blocks.get(i).setC(c-blocks.get(i).getRFromCenter());
               blocks.get(i).setR(r-blocks.get(i).getCFromCenter());
            }
         }
         if (!isMoveableDown()){
            Tetris.getGrid()[r][c].setFull(true);
         }
      }
   }

//   public void update() {
//      int resetter = resetTime;
//      if (speedUp) {
//         resetter = resetTime / 2;
//      } else {
//         resetter = resetTime;
//      }
//      pacer++;
//      if (!collision) {
//         if (pacer % resetter == 0) {
//            System.out.println("run");
//            for (int i = 0; i < blocks.size(); i++) {
//               if (blocks.get(i).getX()
//                     + blocks.get(i).getBlockSize() <= Tetris.gameBoard.getX()
//                           + Tetris.gameBoard.getWidth())
//                  moveableRight = true;
//               else
//                  moveableRight = false;
//               if (blocks.get(i).getX() >= Tetris.gameBoard.getX())
//                  moveableLeft = true;
//               else
//                  moveableLeft = false;
//            }
//            y += speed;
//         }
//            if (right) {
//               System.out.println("help");
//               if (moveableRight) {
//                  x += dx;
//                  setRight(false);
//               }
//            } else if (left) {
//               if (moveableLeft) {
//                  x -= dx;
//                  setLeft(false);
//               }
//            }
//
//            if (rotate) {
//               position++;
//               rotate = false;
//            }
//            if (position >= 4)
//               setPosition(0);
//         }
//         for (int i = 0; i < blocks.size(); i++) {
//            if (right) {
//               blocks.get(i).setLeft(false);
//               blocks.get(i).setRight(true);
//            } else if (left) {
//               blocks.get(i).setRight(false);
//               blocks.get(i).setLeft(true);
//            } else {
//               blocks.get(i).setLeft(false);
//               blocks.get(i).setRight(false);
//            }
//            if (speedUp) {
//               blocks.get(i).setSpeedUp(true);
//            } else
//               blocks.get(i).setSpeedUp(false);
//
//            // dont think it does anymore
//            if (position == 0) {
//               blocks.get(i).setX(x + blocks.get(i).getXFromCenter());
//               blocks.get(i).setY(y + blocks.get(i).getYFromCenter());
//            } else if (position == 1) {
//               blocks.get(i).setX(x + (blocks.get(i).getYFromCenter()));
//               blocks.get(i).setY(y - (blocks.get(i).getXFromCenter()));
//            } else if (position == 2) {
//               blocks.get(i).setX(x - (blocks.get(i).getXFromCenter()));
//               blocks.get(i).setY(y - (blocks.get(i).getYFromCenter()));
//            } else if (position == 3) {
//               blocks.get(i).setX(x - (blocks.get(i).getYFromCenter()));
//               blocks.get(i).setY(y - (blocks.get(i).getXFromCenter()));
//            } else {
//               position = 0;
//            }
//         
//      }
//   }


   public String toString() {
      return this.getClass().getName() + "[" + label + "(" + r + "," + c
            + "),size=" + blockSize + "p=" + position + "]";
   }

   public int getR() {
      return r;
   }
   public void setR(int r) {
      this.r = r;
   }
   public int getC() {
      return c;
   }
   public void setC(int c) {
      this.c = c;
   }
   public boolean isLeft() {
      return left;
   }
   public void setLeft(boolean left) {
      this.left = left;
   }
   public boolean isRight() {
      return right;
   }
   public void setRight(boolean right) {
      this.right = right;
   }
   public boolean isSpeedUp() {
      return speedUp;
   }
   public void setSpeedUp(boolean speedUp) {
      this.speedUp = speedUp;
   }
   public String getLabel() {
      return label;
   }
   public void setLabel(String label) {
      this.label = label;
   }
   public ArrayList<TetrisBlock> getBlocks() {
      return blocks;
   }
   public void setBlocks(ArrayList<TetrisBlock> blocks) {
      this.blocks = blocks;
   }
   public Color getColor() {
      return color;
   }
   public void setColor(Color color) {
      this.color = color;
   }
   public int getBlockSize() {
      return blockSize;
   }
   public void setBlockSize(int blockSize) {
      this.blockSize = blockSize;
   }
   public int getPosition() {
      return position;
   }
   public void setPosition(int i) {
      this.position = i;
   }

   public int getDx() {
      return dx;
   }

   public void setDx(int dx) {
      this.dx = dx;
   }

   public int getBlockAmount() {
      return blockAmount;
   }

   public void setBlockAmount(int blockAmount) {
      this.blockAmount = blockAmount;
   }

   public boolean isCollision() {
      return collision;
   }

   public void setCollision(boolean collision) {
      this.collision = collision;
   }

   public boolean isClear() {
      return clear;
   }

   public void setClear(boolean clear) {
      this.clear = clear;
   }

   public boolean isRotatable() {
      return rotatable;
   }

   public void setRotatable(boolean rotatable) {
      this.rotatable = rotatable;
   }

   public int getResetTime() {
      return resetTime;
   }

   public void setResetTime(int resetTime) {
      this.resetTime = resetTime;
   }

   public boolean isRotate() {
      return rotate;
   }

   public void setRotate(boolean rotate) {
      this.rotate = rotate;
   }

   public int getGround() {
      return ground;
   }

   public void setGround(int ground) {
      this.ground = ground;
   }

   public Location[][] getGrid() {
      return grid;
   }

   public void setGrid(Location[][] grid) {
      this.grid = grid;
   }
   public Location getLocation(){
      if (location == null){
         return new Location(r,c);
      }
      else
         return location;
   }
   public void setLocation(Location l){
      this.location = l;
   }
   public void setLocation(int r, int c){
      this.location = grid[r][c];
   }

   public boolean isMoveableRight() {
      return moveableRight;
   }

   public void setMoveableRight(boolean moveableRight) {
      this.moveableRight = moveableRight;
   }

   public boolean isMoveableLeft() {
      return moveableLeft;
   }

   public void setMoveableLeft(boolean moveableLeft) {
      this.moveableLeft = moveableLeft;
   }

   public boolean isMoveableDown() {
      return moveableDown;
   }

   public void setMoveableDown(boolean moveableDown) {
      this.moveableDown = moveableDown;
   }

   public boolean isStill() {
      return still;
   }

   public void setStill(boolean still) {
      this.still = still;
   }
}
