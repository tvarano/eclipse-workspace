import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

//Thomas Varano
//[Program Descripion]
//Mar 1, 2017

public class CutsceneNPC
{
   private final int RIGHT = 0, LEFT = 1, STILL = 2;
   private int direction, currentAmountSteps;
   private double x, y,width,height,dx,dy, maxSpeed;
   private boolean jumping, falling, doneWorking, animating,commandsDone;
   private Color color;
   private BufferedImage[] stillSheet, horizontalSheet, jumpSheet, verticalSheet;
   private Animation animator;
   private BufferedImage sheet;
   private Scanner reader;
   private File script;
   private Command[] commands;
   private double gravity;
      
   public CutsceneNPC(double x, double y, double width, double height, double maxSpeed, File script){
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.setMaxSpeed(maxSpeed);
      jumping = falling = false;
      animator = new Animation(100);
      this.setScript(script);
      try {
         reader = new Scanner(script);
      } catch (FileNotFoundException e) {
         e.printStackTrace();
      }
   }
   
   public void jump(double jumpForce, double stopY, int index){
      if(!commands[index].isDoneSwitch()){
         if(!falling){
            dy -=jumpForce;
            falling = true;
         }
         else{
            dy+=gravity;
         }
         if (y>=stopY)
            commands[index].setDone(true);
      }
   }
   
   private void moveVertical(double distance, long millisTiming, int index){
      dy = distance/millisTiming;
      if(!commands[index].isDoneTime()) {
         y+=dy;
      }
      else{
         dy = 0;
      }
   }
   
   private void moveHorizontal(double distance, long millisTiming, int index){
      dx = distance/millisTiming;
      if(!commands[index].isDoneTime()) {
         x+=dx;
      }
      else{
         dx = 0;
      }
   }
   
   public void update(){
      if (!reader.hasNextLine())
         doneWorking = true;
      if (commandsDone){
         currentAmountSteps = -1;
         commands = getCommandArray(reader.nextLine());
      }
      else{
         executeCommands(commands);
      }
   }
   
   private Command[] getCommandArray(String commandString){
      int[] punctuationIndex;
      int currentIndex = 0;
      String[] commandStringArray;
      for (char currentChar : commandString.toCharArray()){
         if(currentChar == ';' || currentChar == '*' || currentChar == '$'){
            currentAmountSteps++;
         }
      }
      punctuationIndex = new int[currentAmountSteps+1];
      for (int i = 0; i<commandString.toCharArray().length; i++){
         if (commandString.toCharArray()[i] == ';' ||
               commandString.toCharArray()[i] == '*' ||
               commandString.toCharArray()[i] == '$'){
            punctuationIndex[currentIndex] = i;
            currentIndex++;
         }
      }
      currentIndex = 0;
      System.out.println("amount"+currentAmountSteps);
      System.out.println(commandString);
      commandStringArray = new String[currentAmountSteps];
      Command[] commandArray = new Command[currentAmountSteps];
      int currentStep = 0;
      for (int i = 0; i<currentAmountSteps; i++){
         System.out.println("\nrun"+i);
         System.out.println("step"+currentStep);
         commandStringArray[i] = commandString.substring(
               punctuationIndex[currentIndex],punctuationIndex[currentIndex+1]);
         currentIndex++;
      }
      
      System.out.println();
      for (String current : commandStringArray)
         System.out.println(current);
      
      String currentString;
      for (int i = 0; i<commandStringArray.length; i++){
         currentString = commandStringArray[i];
         if (currentString.charAt(0) == '*'){
            commandArray[i] = new Command(currentString.substring(1, currentString.indexOf('(')),
                  Double.parseDouble(currentString.substring(currentString.indexOf('(')+1, 
                        currentString.indexOf(','))),
                  Double.parseDouble(currentString.substring(currentString.indexOf(',')+1)));
         }
         else if (currentString.charAt(0) == '$'){
            commandArray[i] = new Command(currentString.substring(1, currentString.indexOf('(')),
                  currentString.substring(currentString.indexOf('(')+1));
         }
         else if (currentString.charAt(0) ==';'){
            commandArray[i] = new Command(currentString.substring(1, currentString.indexOf('(')),
                  Double.parseDouble(currentString.substring(currentString.indexOf('(')+1, 
                        currentString.indexOf(','))),
                  Long.parseLong(currentString.substring(currentString.indexOf(',')+1)));
         }
      }
      return commandArray;
   }  
   private void executeCommands(Command[] commandArray){
      for(int i = 0; i<commandArray.length; i++){
         readCommand(commandArray[i], i);
      }
      for (int i = 0; i<commandArray.length; i++){
         if (!commandArray[i].isDoneTime() && !commandArray[i].isDoneSwitch()){
            commandsDone = false;
            break;
         }
         else{
            if (i == commandArray.length-1)
               commandsDone = true;
         }
      }
   }
   //TODO include delay on switching the sheet
   public void readCommand(Command c, int index){
      if (c.getLabel().equals("vertical")){
         moveVertical(c.getParameterOne(),c.getMillisTiming(),index);
      }
      else if(c.getLabel().equals("horizontal")){
         moveHorizontal(c.getParameterOne(),c.getMillisTiming(),index);
      }
      else if(c.getLabel().equals("jump")){
         jump(c.getParameterOne(),c.getParameterTwo(),index);
      }
      else if (c.getLabel().equals("switchSheet")){
         animator.setFrames(switchForSheet(c.getStringParam()));
      }
   }
   
   public BufferedImage[] switchForSheet(String sheet){
      if (animating){
         switch (sheet){
            case "still" : {
               animator.setRunBackwards(false);
               direction = STILL;
               return stillSheet;
            }
            case "left" : {
               animator.setRunBackwards(false);
               direction = LEFT;
               return horizontalSheet;
            }
            case "right" : {
               animator.setRunBackwards(false);
               direction = RIGHT;
               return horizontalSheet;
            }
            case "jump" : {
               animator.setRunBackwards(false);
               direction = STILL;
               return jumpSheet;
            }
            case "up" : {
               animator.setRunBackwards(false);
               direction = STILL;
               return verticalSheet;
            }
            case "down" : { 
               animator.setRunBackwards(true);
               direction = STILL;
               return verticalSheet;
            }
            default : {
               animator.setRunBackwards(true);
               direction = STILL;
               return null;
            }
         }
      }
      //TODO dont wanna return null
      return null;
   }
   
   public void draw(Graphics2D g2){
      if(animating){
         if (direction == RIGHT || direction == STILL)
            g2.drawImage(animator.getImage(),(int)x,(int)y,(int)width,(int)height,null);
         else if (direction == LEFT)
            g2.drawImage(animator.getImage(),(int)x,(int)(y+width),(int)-width,(int)height,null);
      }
      else
         g2.fill(getBounds());
   }
   
   public Rectangle getBounds(){
      return new Rectangle((int)x,(int)y,(int)width,(int)height);
   }
   
   public double getX() {
      return x;
   }
   public void setX(double x) {
      this.x = x;
   }
   public double getY() {
      return y;
   }
   public void setY(double y) {
      this.y = y;
   }
   public double getWidth() {
      return width;
   }
   public void setWidth(double width) {
      this.width = width;
   }
   public double getHeight() {
      return height;
   }
   public boolean isAnimating() {
      return animating;
   }

   public void setAnimating(boolean animating) {
      this.animating = animating;
   }

   public BufferedImage[] getStillSheet() {
      return stillSheet;
   }

   public void setStillSheet(BufferedImage[] stillSheet) {
      this.stillSheet = stillSheet;
   }

   public BufferedImage[] getWalkSheet() {
      return horizontalSheet;
   }

   public void setWalkSheet(BufferedImage[] horizontalSheet) {
      this.horizontalSheet = horizontalSheet;
   }

   public BufferedImage[] getJumpSheet() {
      return jumpSheet;
   }

   public void setJumpSheet(BufferedImage[] jumpSheet) {
      this.jumpSheet = jumpSheet;
   }

   public BufferedImage[] getVerticalSheet() {
      return verticalSheet;
   }

   public void setVerticalSheet(BufferedImage[] verticalSheet) {
      this.verticalSheet = verticalSheet;
   }

   public void setHeight(double height) {
      this.height = height;
   }
   public double getDx() {
      return dx;
   }
   public void setDx(double dx) {
      this.dx = dx;
   }
   public double getDy() {
      return dy;
   }
   public void setDy(double dy) {
      this.dy = dy;
   }
   public boolean isJumping() {
      return jumping;
   }
   public void setJumping(boolean jumping) {
      this.jumping = jumping;
   }
   public boolean isFalling() {
      return falling;
   }
   public void setFalling(boolean falling) {
      this.falling = falling;
   }
   public Color getColor() {
      return color;
   }
   public void setColor(Color color) {
      this.color = color;
   }
   
   public double getMaxSpeed() {
      return maxSpeed;
   }

   public void setMaxSpeed(double maxSpeed) {
      this.maxSpeed = maxSpeed;
   }

   public BufferedImage getSheet() {
      return sheet;
   }

   public void setSheet(BufferedImage sheet) {
      this.sheet = sheet;
   }

   public boolean isDoneWorking() {
      return doneWorking;
   }

   public void setDoneWorking(boolean doneWorking) {
      this.doneWorking = doneWorking;
   }

   public File getScript() {
      return script;
   }

   public void setScript(File script) {
      this.script = script;
   }

   public double getGravity() {
      return gravity;
   }

   public void setGravity(double gravity) {
      this.gravity = gravity;
   }
}
